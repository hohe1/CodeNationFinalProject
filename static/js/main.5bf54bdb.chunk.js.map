{"version":3,"sources":["components/TargetBar.js","components/SelfBar.js","components/GameCanvas.js","App.js","serviceWorker.js","index.js"],"names":["TargetBar","props","myRef","React","createRef","state","barColor","this","target","className","toPercent","hp","maxHp","name","style","width","Component","SelfBar","toPercentHp","mhp","toPercentMp","mp","mmp","defArr","i","def","push","key","GameCanvas","contx","mobBeingHit","charHp","charMp","charDef","mainCharStat","charPosition","x","y","flip","appearance","sprite","frame","totalFrame","resetAfterFinish","resetToAfterFinish","stat","maxhp","maxmp","atk","wlkSpd","moveSet","knockBack","Lcharge","arrayOfMobs","arrayOfProjectiles","sprites","charWalk","img","Image","charAtk1","charAtk2","charAtk3","charBlock","charDied","swordWave","blade","greenBoiWalk","greenBoiAtk","madManAtk1","madManSkill1","madManSkill2","madmanWalk","src","mobStat","greenBoi","knockResistance","skills","isAttking","cd","walk","attack","behavior","self","mobSpritePlay","atkCd","otherVar","boardKeyState","downK","setState","mobWalkSprite","madMan","mode","hasJumped","Math","random","makeProjectile","floor","mech","forEach","v","levels","mob","posX","posY","gameTick","gameTime","downW","downA","downS","downD","downJ","downL","currentLevel","levelCompleted","wound","arrow","setSpriteForWalking","playSprite","sheetName","distanceFromChar","checkForReset","moveChar","contex","collisionDetection","appendMob","canvasContex","drawImage","moveMobs","appendProjectile","showHitBox","ctx","beginPath","lineWidth","strokeStyle","rect","stroke","console","log","clearDeadMob","splice","length","nextLevel","MakeMob","alert","checkForMobDie","mobType","spawnX","spawnY","Projectile","window","onload","current","getContext","height","setInterval","clearRect","onkeydown","e","toUpperCase","onkeyup","focus","ref","onLoad","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.5bf54bdb.chunk.js","sourcesContent":["import React, { Component } from 'react'\n\nexport default class TargetBar extends Component{\n    constructor(props){\n        super(props)\n        this.myRef = React.createRef();\n\n        this.state = {\n            barColor:\"red\"\n        }\n    }\n    render(){\n        \n        if(this.props.target === null){ //when you're hitting anything\n            return(\n\n                <div className=\"TargetBar\">\n                    <div className=\"nameMob\">-</div>\n                    <div className=\"hpHolder\"><span className=\"hp\"></span></div>\n                </div>\n            )\n        }else{\n            let hpWidth = this.props.target.hp / this.props.target.maxHp\n            let toPercent = hpWidth*100 + \"%\"\n            //console.log(toPercent)\n\n            return(\n\n                <div className=\"TargetBar\">\n                    <div className=\"nameMob\">Currenly Fighting: {this.props.target.name}</div>\n                    <div className=\"hpHolder\">\n                        <div className=\"hp\" style={{width:toPercent}}></div>\n                    </div>\n                </div>\n            )\n        }\n    }\n}","import React, { Component } from 'react'\n\nexport default class SelfBar extends Component{\n    constructor(props){\n        super(props)\n        this.myRef = React.createRef();\n\n        this.state = {\n            barColor:\"red\"\n        }\n    }\n    render(){            \n            let hpWidth = this.props.hp / this.props.mhp\n            let toPercentHp = hpWidth*100 + \"%\"\n\n            let mpWidth = this.props.mp / this.props.mmp\n            let toPercentMp = mpWidth*100 + \"%\"\n\n            if(this.props.hp  < 0){\n                toPercentHp = 0\n            }\n            if(this.props.mp  < 0){\n                toPercentMp = 0\n            }\n\n            let defArr = []\n            for(let i=0;i<this.props.def;i++){\n                defArr.push(<div className=\"def\" key={i+\"def\"}></div>)\n            }\n\n        return(\n            <div className=\"charUI\">\n                <div className=\"yourBars\">\n\n                    <div className=\"hpHolderChar\">\n                        <div className=\"hpChar\" style={{width:toPercentHp}}></div>\n                    </div>\n\n                    <div className=\"mpHolderChar\">\n                        <div className=\"mpChar\" style={{width:toPercentMp}}></div>\n                    </div>\n\n                    <div className=\"defHolderChar\">\n                        {defArr}\n                    </div>\n\n                </div>\n                    <div className=\"skills\">\n                </div>\n            </div>\n        )\n    }\n}","import React, { Component, useState } from 'react'\nimport Targetbar from './TargetBar.js';\nimport SelfBar from './SelfBar.js';\n\nconst constantVar = {\n\n}\n\nexport default class GameCanvas extends Component{\n    constructor(props){\n        super(props)\n        this.myRef = React.createRef();\n\n        this.state = {\n            mobBeingHit: null,\n            charHp: 250,\n            charMp: 250,\n            charDef: 3\n        }\n        //-------var---------------\n        this.mainCharStat = { \n            charPosition:{\n                x:0,\n                y:0,\n                flip:false, //face different direction, use when turn around. (not impermented)\n            },\n            appearance:{\n                sprite:null,\n                frame:0,\n                totalFrame:0,\n                resetAfterFinish : false,\n                resetToAfterFinish : null,\n            },\n            stat:{\n                maxhp:250, \n                maxmp:250, \n                atk: 10,\n                wlkSpd: 10, // not in use at the moment\n                moveSet:0,\n                knockBack: 8,\n                Lcharge: 0,\n                \n            }\n        }\n\n        this.arrayOfMobs = [] //stores mobs obj that currently exist.\n        this.arrayOfProjectiles = []\n\n        this.sprites = {\n            //player's character sprites\n            charWalk : {\n                img: new Image(),\n                totalFrame: 4, //just start count at 1 here\n            },\n\n            charAtk1 : {\n                img: new Image(),\n                totalFrame: 7, //just start count at 1 here\n            },\n\n            charAtk2 : {\n                img: new Image(),\n                totalFrame: 6, //just start count at 1 here\n            },\n\n            charAtk3 : {\n                img: new Image(),\n                totalFrame: 5, //just start count at 1 here\n            },\n\n            charBlock : {\n                img: new Image(),\n                totalFrame: 1, //just start count at 1 here\n            },\n            charDied : {img: new Image(),totalFrame: 1},\n            //projectiles\n            swordWave:{img: new Image(),totalFrame: 1},\n            blade:{img: new Image(),totalFrame: 1},\n            //mob sprties\n            greenBoiWalk:{img: new Image(),totalFrame: 4,},\n            greenBoiAtk:{img: new Image(),totalFrame: 7,},\n\n            madManAtk1:{img: new Image(),totalFrame: 6},\n            madManSkill1:{img: new Image(),totalFrame: 6},\n            madManSkill2:{img: new Image(),totalFrame: 4},\n            madmanWalk:{img: new Image(),totalFrame: 2}\n\n        }\n        this.sprites.charWalk.img.src = \"../../../pictures/walkSprite.png\" //set the src of the img initialized ^\n        this.sprites.charAtk1.img.src = \"../../../pictures/charAtk1Sprite.png\"\n        this.sprites.charAtk2.img.src = \"../../../pictures/charAtk2Sprite.png\"\n        this.sprites.charAtk3.img.src = \"../../../pictures/charAtk3Sprite.png\"\n        this.sprites.charBlock.img.src = \"../../../pictures/mainChar_block.png\"\n        this.sprites.charDied.img.src = \"../../../pictures/mainChar_Died.png\"\n\n        this.sprites.swordWave.img.src = \"../../../pictures/swordWave.png\"\n        this.sprites.blade.img.src = \"../../../pictures/madman_blade.png\"\n\n        this.sprites.greenBoiWalk.img.src = \"../../../pictures/walkSprite2.png\"\n        this.sprites.greenBoiAtk.img.src = \"../../../pictures/GreenAtk1Sprite.png\"\n\n        this.sprites.madManAtk1.img.src = \"../../../pictures/madman_atk.png\"\n        this.sprites.madManSkill1.img.src = \"../../../pictures/madman_skill.png\"\n        this.sprites.madManSkill2.img.src = \"../../../pictures/madman_skill2.png\"\n        this.sprites.madmanWalk.img.src = \"../../../pictures/madman_walk.png\"\n\n        this.mobStat = { //spawn mobs using these stats\n            greenBoi:{\n                hp:250,\n                atk:10,\n                wlkSpd:5,\n                knockResistance:0,\n                skills:[],\n                isAttking: false,\n                cd: 14,\n                sprites:{\n                    walk: this.sprites.greenBoiWalk, //need to do walk.img to get the img.\n                    attack:null,\n                },\n                behavior: (self)=>{\n                    //move towards player: set the position so next time it renders closer to the player\n                    \n                    //wait some time\n                    \n                    //still within attack range? (64px?)\n                    if(self.charPosition.x <= this.mainCharStat.charPosition.x + 50 && self.charPosition.x+50 >= this.mainCharStat.charPosition.x){//x works fine  //changed to 100 so mob walk closer, sheet 128^2 \n                        if(self.charPosition.y <= this.mainCharStat.charPosition.y + 50 && self.charPosition.y+50 >= this.mainCharStat.charPosition.y){  //need to change mobwalksprite so he will get close enough\n                            //this.mainCharStat.hp -= this.mainCharStat.stat.atk\n                            //this.playSprite(\"charAtk1\",self)\n                            this.mobSpritePlay(self,\"greenBoiAtk\") //attack begin\n\n                            if(!self.isAttking && self.atkCd === 0 && self.appearance.frame%self.appearance.totalFrame === 3){ //only attaks once per animation\n                                if(this.otherVar.boardKeyState.downK && this.state.charDef > 0){ // if player is holding down k key, aka if blocking\n                                    this.setState({\"charDef\": this.state.charDef - 1 })  //player blocked attack\n                                }else{\n                                    this.setState({\"charHp\": this.state.charHp - self.atk })  //player gets hurt\n                                }\n                                self.isAttking = true\n                                self.atkCd = self.cd\n                            }\n                                \n                        }else{\n                            //still not in range, walk\n                            this.mobWalkSprite(self,49)\n                        }\n                    }else{\n                     //else not in range. Start walking\n                     this.mobWalkSprite(self,49)\n                    }\n                    \n\n                    //wait for cd\n                    if(self.atkCd > 0){\n                        self.atkCd -= 1\n                        if (self.appearance.frame % self.appearance.totalFrame === 0){\n                            self.appearance.frame = 0\n                            this.mobWalkSprite(self,49)\n                        }\n                    }\n                    //reset isAttacking\n                    if(self.appearance.frame % self.appearance.totalFrame === 0){\n                        self.isAttking = false\n                    }\n                    //repaet until died\n                },\n                \n            },\n\n            madMan:{\n                hp:666,\n                atk:66,\n                wlkSpd:10,\n                knockResistance:0,\n                skills:[],\n                isAttking: false,\n                cd: 10,\n                sprites:{\n                    walk: this.sprites.madmanWalk, //need to do walk.img to get the img.\n                    attack:null,\n                },\n                behavior: (self)=>{\n                    let mode\n                    if(self.hp/self.maxHp >= .7){\n                        mode = \"rush\"\n                    }else if(self.hp/self.maxHp >= .5){\n                        mode = \"jump\"\n                    }else if(self.hp/self.maxHp >= .2){\n                        self.knockResistance = 100 //prevent knock back\n                        self.wlkSpd = 0\n                        mode = \"throw\"\n                    }else if(self.hp/self.maxHp >= 0){\n                        self.sprites.walk = this.sprites.madManSkill2\n                        self.wlkSpd = 3\n                        self.cd = 0\n                        mode = \"rush\"\n                    }\n\n                    //when madman have >80% hp: rushes player\n                    switch(mode){\n                        case \"rush\":\n                            if(self.charPosition.x <= this.mainCharStat.charPosition.x + 50 && self.charPosition.x+50 >= this.mainCharStat.charPosition.x){//x works fine  //changed to 100 so mob walk closer, sheet 128^2 \n                                if(self.charPosition.y <= this.mainCharStat.charPosition.y + 30 && self.charPosition.y+30 >= this.mainCharStat.charPosition.y){  //need to change mobwalksprite so he will get close enough\n                                    this.mobSpritePlay(self,\"madManAtk1\") //attack begin\n\n                                    if(!self.isAttking && self.atkCd === 0 && self.appearance.frame%self.appearance.totalFrame === 2){ //only attaks once per animation\n                                        if(this.otherVar.boardKeyState.downK && this.state.charDef > 0){ // if player is holding down k key, aka if blocking\n                                            this.setState({\"charDef\": this.state.charDef - 1 })  //player blocked attack\n                                        }else{\n                                            this.setState({\"charHp\": this.state.charHp - self.atk })  //player gets hurt\n                                        }\n                                        self.isAttking = true\n                                        self.atkCd = self.cd\n                                    }\n                                        \n                                }else{\n                                    //still not in range, walk\n                                    this.mobWalkSprite(self,49)\n                                }\n                            }else{\n                            //else not in range. Start walking\n                            this.mobWalkSprite(self,49)\n                            }\n                        break;\n\n                        case \"jump\":\n                            if(self.charPosition.x <= this.mainCharStat.charPosition.x + 50 && self.charPosition.x+50 >= this.mainCharStat.charPosition.x){//x works fine  //changed to 100 so mob walk closer, sheet 128^2 \n                                if(self.charPosition.y <= this.mainCharStat.charPosition.y + 30 && self.charPosition.y+30 >= this.mainCharStat.charPosition.y){  //need to change mobwalksprite so he will get close enough\n                                    this.mobSpritePlay(self,\"madManAtk1\") //attack begin\n\n                                    if(!self.isAttking && self.atkCd === 0 && self.appearance.frame%self.appearance.totalFrame === 2){ //only attaks once per animation\n                                        if(this.otherVar.boardKeyState.downK && this.state.charDef > 0){ // if player is holding down k key, aka if blocking\n                                            this.setState({\"charDef\": this.state.charDef - 1 })  //player blocked attack\n                                        }else{\n                                            this.setState({\"charHp\": this.state.charHp - self.atk })  //player gets hurt\n                                        }\n                                        self.isAttking = true\n                                        self.atkCd = self.cd\n                                    }  \n                                        \n                                }\n\n                            }else{\n                            //else not in range. Start jumping\n                                if(self.hasJumped === \"finished\"){\n                                    this.mobWalkSprite(self,49)\n\n                                    if(Math.random() > 0.7){\n                                        self.hasJumped = false\n                                    }\n                                }\n\n                                if(self.charPosition.y>-200 && self.atkCd<=0 && self.hasJumped===false){ //jumps off screen\n                                    self.charPosition.y-=self.wlkSpd*8\n                                }else if(self.charPosition.y<=-200 && self.hasJumped===false){  //reached y = -200, start faillinf\n                                    self.hasJumped = true\n                                    self.charPosition.x = this.mainCharStat.charPosition.x\n                                }\n                                //console.log(self.hasJumped)\n                            }\n\n                            if(self.charPosition.x<500 && self.atkCd>0){ //runs away after hitting\n                                self.charPosition.x+=self.wlkSpd*5\n                            }\n\n                            if(self.hasJumped === true && self.atkCd<=0 && self.charPosition.y < this.mainCharStat.charPosition.y){ //if not reach player y, keep failling\n                                self.charPosition.y+=self.wlkSpd*5\n                                //console.log(self.charPosition.y ,  this.mainCharStat.charPosition.y)\n                            }else if(self.hasJumped === true && self.atkCd<=0 && self.charPosition.y >= this.mainCharStat.charPosition.y){ //landed\n                                self.hasJumped = \"finished\"\n                                this.mobWalkSprite(self,49)\n                            }\n                        break;\n                        \n                        case \"throw\":\n                            if(self.charPosition.y<300){ //runs to side of screen\n                                self.charPosition.y += 3\n                            }\n                            if(self.charPosition.x<500){ //runs to side of screen\n                                self.charPosition.x += 3\n                            }\n\n                            //attack begin\n\n                            if(self.atkCd === 0){\n                                this.mobSpritePlay(self,\"madManSkill2\")\n                                if(self.appearance.frame%self.appearance.totalFrame === 3){\n                                    this.makeProjectile(\"blade\",\n                                    self.charPosition.x + -20+Math.floor(Math.random()*40),\n                                    self.charPosition.y-5)\n                                    self.atkCd = self.cd\n                                }\n                            }\n                        break;\n\n                    }\n                     //wait for cd\n                     if(self.atkCd > 0){\n                        self.atkCd -= 1\n                        if (self.appearance.frame % self.appearance.totalFrame === 0 && mode !==\"throw\"){\n                            self.appearance.frame = 0 //when there is atkcd animation will not play\n                            this.mobWalkSprite(self,49)\n                        }\n                    }\n                    //reset isAttacking\n                    if(self.appearance.frame % self.appearance.totalFrame === 0){\n                        self.isAttking = false\n                    }\n                }\n\n            },\n\n            mech:{},\n            \n            //projectiles\n            swordWave:{\n                name:\"swordWave\",\n                hp : 10,\n                atk:5,\n                wlkSpd:10,\n                sprites: this.sprites.swordWave,\n                behavior: (self)=>{\n                    self.charPosition.x += self.wlkSpd\n\n                    this.arrayOfMobs.forEach((v,i)=>{\n                        if(v.charPosition.x < self.charPosition.x + 32 && v.charPosition.x+32 > self.charPosition.x){//x works fine\n                            //console.log(\"x hit\")\n                            if(v.charPosition.y < self.charPosition.y + 128 && v.charPosition.y+128 > self.charPosition.y){\n                                //console.log(\"y hit\")\n                                v.hp -= self.atk\n                                //console.log(v.hp)\n                                if(v.knockResistance < 25){\n                                    v.charPosition.x += 25\n                                }\n\n                                self.hp -= 2\n                                this.setState({\"mobBeingHit\":v})\n                            }\n                            //not colliding\n                        }\n                    })\n                    self.hp -= 1\n                    //console.log(self.hp)\n                    //destroying the wave will be handled by the cleardeadmob() function\n\n                },\n            },\n\n            blade:{\n                name:\"swordWave\",\n                hp : 15,\n                atk:66,\n                wlkSpd:20,\n                sprites: this.sprites.blade,\n                behavior: (self)=>{\n                    self.charPosition.x -= self.wlkSpd\n                    self.hp -= 1\n\n                    if(self.charPosition.x <= this.mainCharStat.charPosition.x + 50 && self.charPosition.x+50 >= this.mainCharStat.charPosition.x){\n                        if(self.charPosition.y <= this.mainCharStat.charPosition.y + 30 && self.charPosition.y+30 >= this.mainCharStat.charPosition.y){\n                            if(this.otherVar.boardKeyState.downK && this.state.charDef > 0){ \n                                this.setState({\"charDef\": this.state.charDef - 1 })  //player blocked attack\n                                self.hp = 0    \n                            }else{\n                                this.setState({\"charHp\": this.state.charHp - self.atk })  //player gets hurt\n                                self.hp = 0    \n                            }\n                        }\n                    }\n                    //console.log(self.hp)\n                }\n            }\n\n        }\n\n        this.levels=[\n            [{mob:\"greenBoi\",posX:0,posY:400}], //this will not spawn due to lvl 0\n            \n            [{mob:\"greenBoi\",posX:200,posY:200}],\n            [{mob:\"greenBoi\",posX:200,posY:200},{mob:\"greenBoi\",posX:200,posY:300},{mob:\"greenBoi\",posX:200,posY:100}],\n            [{mob:\"madMan\",posX:0,posY:400}], //each of these array contain the mobs to be spawn when player enter a new room\n            [{mob:\"greenBoi\",posX:100,posY:100},{mob:\"greenBoi\",posX:200,posY:200},{mob:\"greenBoi\",posX:300,posY:300},{mob:\"greenBoi\",posX:400,posY:400},{mob:\"greenBoi\",posX:500,posY:500}]\n\n        ]\n\n        //set char appearance\n        this.mainCharStat.appearance.sprite = this.sprites.charWalk.img\n        this.mainCharStat.appearance.totalFrame = this.sprites.charWalk.totalFrame\n        this.mainCharStat.appearance.resetToAfterFinish = this.sprites.charWalk // not add .img so can get frame also.\n\n        this.otherVar = {\n            gameTick: 125, //125 is pretty good 8fps\n            gameTime: 0,\n            boardKeyState:{\n                downW : false,\n                downA : false,\n                downS : false,\n                downD : false,\n\n                downJ : false,\n                downK : false,\n                downL : false,\n            },\n            currentLevel:0,\n            levelCompleted:false,\n            wound : new Image(),\n            arrow : new Image()\n\n        }\n        this.otherVar.wound.src = \"../../../pictures/wound.png\"\n        this.otherVar.arrow.src = \"../../../pictures/arrow.png\"\n\n        //-------methods-----------------\n        this.setSpriteForWalking = ()=>{\n            this.mainCharStat.appearance.sprite = this.sprites.charWalk.img\n            this.mainCharStat.appearance.totalFrame = this.sprites.charWalk.totalFrame\n            this.mainCharStat.appearance.frame += 1\n        } \n\n        this.playSprite = (sheetName,target) => {\n            this[target].appearance.frame = 0\n            this[target].appearance.sprite = this.sprites[sheetName].img\n            this[target].appearance.totalFrame = this.sprites[sheetName].totalFrame\n            this[target].appearance.resetAfterFinish = true\n\n            //console.log(this[target].appearance.sprite)\n            //console.log(this[target].appearance.totalFrame)\n        }\n\n        this.mobSpritePlay = (target,sheetName)=>{ //target is self\n            if(target.appearance.resetAfterFinish === false){\n                target.appearance.frame = 0\n                target.appearance.sprite = this.sprites[sheetName].img\n                target.appearance.totalFrame = this.sprites[sheetName].totalFrame\n                target.appearance.resetAfterFinish = true\n            }else{\n                target.appearance.frame += 1\n\n            }\n        }\n\n        this.mobWalkSprite=(target,distanceFromChar)=>{ //target is self\n            target.appearance.resetAfterFinish = false\n            target.appearance.sprite = this.mobStat[target.name].sprites.walk.img\n            target.appearance.totalFrame = this.mobStat[target.name].sprites.walk.totalFrame\n            target.appearance.frame += 1\n\n            if(target.charPosition.x >= this.mainCharStat.charPosition.x + distanceFromChar){ //if not within x range   Main +128 Self  //128 and the boxes are touching(pretty much)\n                target.charPosition.x -= target.wlkSpd                                 //put 94 instead of 128 because it mob walk closer\n            }else if(target.charPosition.x+distanceFromChar <= this.mainCharStat.charPosition.x){\n                target.charPosition.x += target.wlkSpd\n            }\n            \n            if(target.charPosition.y !== this.mainCharStat.charPosition.y){\n                if(target.charPosition.y >= this.mainCharStat.charPosition.y){\n                    target.charPosition.y -= target.wlkSpd\n                }else if(target.charPosition.x <= this.mainCharStat.charPosition.y){\n                    target.charPosition.y += target.wlkSpd\n                }\n            }\n\n        }\n\n        this.checkForReset = (target) =>{ //checks for reset and loops sprite\n            if (this[target].appearance.resetAfterFinish === true){\n                //console.log(\"a\")\n                //console.log(this[target].appearance.frame) //will print the frame of the current playing sprite\n                if(this[target].appearance.totalFrame > this[target].appearance.frame){\n                    this[target].appearance.frame+=1 //enable later when \n                }else{\n                    this[target].appearance.sprite = this[target].appearance.resetToAfterFinish.img\n                    this[target].appearance.totalFrame = this[target].appearance.resetToAfterFinish.totalFrame\n                    this[target].appearance.frame = 0\n                    this[target].appearance.resetAfterFinish=false\n                    \n\n                }\n            }\n\n        }\n\n        this.moveChar = (contex)=>{ //much public contex yes, very secure /s\n\n            if (this.otherVar.boardKeyState.downJ === true && this.mainCharStat.appearance.resetAfterFinish === false){ //false prevent this from excuting many time\n\n                switch(this.mainCharStat.moveSet){\n                    case 1:\n                        this.playSprite(\"charAtk2\",\"mainCharStat\")\n                        this.mainCharStat.moveSet += 1\n                        this.mainCharStat.stat.knockBack = 40\n                    break;\n                    case 2:\n                        this.playSprite(\"charAtk3\",\"mainCharStat\")\n                        this.mainCharStat.moveSet += 1\n                        this.mainCharStat.stat.knockBack = 10\n                        this.mainCharStat.stat.atk = 20\n                    break;\n                    default: //aka case 0\n                        this.playSprite(\"charAtk1\",\"mainCharStat\")\n                        this.mainCharStat.moveSet = 1 //since you just played case 0, set case to 1\n                        this.mainCharStat.stat.knockBack = 10\n                        this.mainCharStat.stat.atk = 10\n                }\n\n                this.collisionDetection(contex)\n            \n                \n            }else if(this.otherVar.boardKeyState.downK === true){\n                this.playSprite(\"charBlock\",\"mainCharStat\")\n                \n            }else if(this.otherVar.boardKeyState.downL === true){\n                this.playSprite(\"charAtk2\",\"mainCharStat\")\n                \n                if(this.state.charMp>=50 && this.mainCharStat.stat.Lcharge === 0){\n                    this.setState({\"charMp\":this.state.charMp - 50}) \n                    this.mainCharStat.stat.Lcharge += 1\n                }\n                if(this.state.charMp > 3 && this.mainCharStat.stat.Lcharge >= 1){\n                    this.mainCharStat.stat.Lcharge += 1 //charge up atk (check for Lkey = false and Lcharge value)\n                    this.setState({\"charMp\":this.state.charMp - 3})\n                }\n                \n\n                //console.log(this.mainCharStat.stat.Lcharge)\n\n            }else{\n\n                if (this.otherVar.boardKeyState.downW === true){\n                    this.mainCharStat.charPosition.y-=10;\n                    this.mainCharStat.appearance.frame+=1\n                }\n                \n                if (this.otherVar.boardKeyState.downA === true){\n                    this.mainCharStat.charPosition.x-=10;\n                    this.mainCharStat.appearance.frame+=1\n                }\n            \n                if (this.otherVar.boardKeyState.downS === true){\n                    this.mainCharStat.charPosition.y+=10;\n                    this.mainCharStat.appearance.frame+=1\n                }\n        \n                if (this.otherVar.boardKeyState.downD === true){\n                    this.mainCharStat.charPosition.x+=10;\n                    this.mainCharStat.appearance.frame+=1\n\n                }\n                //this.setSpriteForWalking()\n            }\n        }\n\n        this.appendMob = (canvasContex)=>{\n            this.arrayOfMobs.forEach((v,i)=>{\n                canvasContex.drawImage(\n                    v.appearance.sprite,   //img\n                    (v.appearance.frame % v.appearance.totalFrame)*128,    //sx\n                    0,    //sy\n                    128,    //swidth\n                    128,    //sheight\n                    v.charPosition.x,    //x\n                    v.charPosition.y,    //y\n                    128,    //width\n                    128    //height\n                    )\n            })\n        }\n\n        this.moveMobs =()=>{\n            this.arrayOfMobs.forEach((v,i)=>{\n                v.behavior(v)\n            })\n\n            this.arrayOfProjectiles.forEach((v,i)=>{\n                v.behavior(v)\n            })\n        }\n\n        this.appendProjectile = (canvasContex)=>{\n            this.arrayOfProjectiles.forEach((v,i)=>{\n                canvasContex.drawImage(\n                    v.appearance.sprite.img,   \n                    v.charPosition.x,    \n                    v.charPosition.y,    \n                    128,    \n                    128,     \n                    )\n                //console.log(v)\n            })\n        }\n\n        this.showHitBox = (ctx)=>{ //will crash if you kill a mob, there isnt a null check\n            ctx.beginPath();\n            ctx.lineWidth = \"1\";\n            ctx.strokeStyle = \"red\";\n            ctx.rect(this.mainCharStat.charPosition.x,this.mainCharStat.charPosition.y,128,128)//draw main char hitbox (not actually hit box, but is hit box if you put in the same value as collision Detection.)\n            ctx.rect(this.arrayOfMobs[0].charPosition.x,this.arrayOfMobs[0].charPosition.y,128,128)\n            ctx.stroke();\n        }\n\n        this.collisionDetection = (contex)=>{ //assume 128^2\n            //check for collison if charCenter.x + 64 > mob x or charCenter.x - 64 < mob x + 128, then check the same for y\n            this.arrayOfMobs.forEach((v,i)=>{\n                if(v.charPosition.x < this.mainCharStat.charPosition.x + 128 && v.charPosition.x+128 > this.mainCharStat.charPosition.x){//x works fine\n                    //console.log(\"x hit\")\n                    if(v.charPosition.y < this.mainCharStat.charPosition.y + 128 && v.charPosition.y+128 > this.mainCharStat.charPosition.y){\n                        //console.log(\"y hit\")\n                        v.hp -= this.mainCharStat.stat.atk\n                        //console.log(v.hp)\n\n                        if(v.knockResistance < this.mainCharStat.stat.knockBack){\n                            v.charPosition.x += this.mainCharStat.stat.knockBack - v.knockResistance\n                        }\n\n                       \n                        contex.drawImage(this.otherVar.wound,\n                            v.charPosition.x-32-Math.floor(Math.random()*32), \n                            v.charPosition.y+32+Math.floor(Math.random()*32),\n                            128+Math.floor(Math.random()*128),\n                            32+Math.floor(Math.random()*32)\n                        )\n\n                        //restore block capablitiy\n                        if(this.state.charDef <3){\n                            this.setState({\"charDef\":this.state.charDef+1})\n                        }\n\n                        if(this.state.charMp < 250){ //recover mp when attacking\n                            this.setState({\"charMp\":this.state.charMp+5})\n                        }\n                        this.setState({\"mobBeingHit\":v})\n                        console.log(this.state.mobBeingHit)\n                    }\n                    //not colliding\n                    \n                }\n\n            })\n        }\n\n        this.clearDeadMob = () => {\n            this.arrayOfMobs.forEach((v,i)=>{\n                if (v.hp <= 0){\n                    this.arrayOfMobs.splice(i,1)\n                    \n                    if(this.state.mobBeingHit === v){\n                        this.setState({\"mobBeingHit\":null})\n                    }\n                }\n            })\n\n            this.arrayOfProjectiles.forEach((v,i)=>{\n                if (v.hp <= 0){\n                    this.arrayOfProjectiles.splice(i,1)\n                }\n            })\n\n            if(!this.otherVar.levelCompleted && this.arrayOfMobs.length===0){\n                this.otherVar.levelCompleted = true\n\n            }//next level avaliable\n\n        }\n\n        this.nextLevel=()=>{\n            if(this.mainCharStat.charPosition.x > 700-128 && this.mainCharStat.charPosition.x < 700){//x works fine\n                if(this.mainCharStat.charPosition.y < 250 + 32 && this.mainCharStat.charPosition.y > 250-32){\n                    //console.log(\"gg\") move to next level\n\n                    this.otherVar.currentLevel += 1\n                    this.otherVar.levelCompleted = false\n                    this.mainCharStat.charPosition.x = 0\n                    this.mainCharStat.charPosition.y = 250\n                    this.arrayOfProjectiles = []\n                    //spawn mobs\n\n                    if(this.otherVar.currentLevel < this.levels.length){\n                        this.levels[this.otherVar.currentLevel].forEach((v,i)=>{\n                            this.MakeMob(v.mob,v.posX,v.posY)\n                        })\n                    }else{\n                        alert(\"um, so like you finished all the levels, and like I'm like lazy, look here oldsport I took AP chem today, and Im not sure If is submitted correctly, so pardon my alert(), setting you back to level 0 please stand by...\")\n                        this.otherVar.currentLevel = 0\n                        this.nextLevel()\n                    }\n\n                }\n            }\n        }\n\n        this.checkForMobDie = ()=>{}\n        //--------Mob constructor------------\n        this.MakeMob = (mobType,spawnX,spawnY)=>{\n            let mob = {}\n            mob.name = mobType\n            mob.maxHp = this.mobStat[mobType].hp\n            mob.hp = this.mobStat[mobType].hp\n            mob.atk = this.mobStat[mobType].atk\n            mob.wlkSpd = this.mobStat[mobType].wlkSpd\n            mob.skills = this.mobStat[mobType].skills\n            mob.knockResistance = this.mobStat[mobType].knockResistance\n            mob.cd = this.mobStat[mobType].cd\n            mob.atkCd = 0\n\n            mob.sprites = {}\n            mob.sprites.walk = this.mobStat[mobType].sprites.walk\n\n            mob.charPosition = {}\n            mob.charPosition.x = spawnX\n            mob.charPosition.y = spawnY\n            mob.charPosition.flip = false\n        \n            mob.appearance = {}\n            mob.appearance.sprite = mob.sprites.walk.img\n            mob.appearance.frame = 0\n            mob.appearance.totalFrame = mob.sprites.walk.totalFrame\n            mob.appearance.resetAfterFinish = false\n            mob.appearance.resetToAfterFinish = mob.sprites.walk //.img left out intentionally\n\n            mob.behavior = this.mobStat[mobType].behavior\n            \n            //exceptions\n            if(mobType===\"madMan\"){\n                mob.hasJumped = false\n            }\n\n            // console.log(mob)\n            //push mob in the array that stores mobs\n            this.arrayOfMobs.push(mob)\n            console.log(this.arrayOfMobs)\n        }\n\n        this.makeProjectile = (mobType,spawnX,spawnY)=>{ //yes. mobtype, its stored in mobstat\n            let Projectile = {}\n            Projectile.hp = this.mobStat[mobType].hp\n            Projectile.name = mobType\n            Projectile.atk = this.mobStat[mobType].atk\n            Projectile.wlkSpd = this.mobStat[mobType].wlkSpd\n\n            Projectile.sprites = this.mobStat[mobType].sprites\n\n            Projectile.charPosition = {}\n            Projectile.charPosition.x = spawnX\n            Projectile.charPosition.y = spawnY\n            Projectile.charPosition.flip = false\n        \n            Projectile.appearance = {}\n            Projectile.appearance.sprite = Projectile.sprites\n            Projectile.behavior = this.mobStat[mobType].behavior\n\n            //exceptions\n            if(mobType===\"swordWave\"){\n                Projectile.hp += Math.floor(this.mainCharStat.stat.Lcharge*1)\n                this.mainCharStat.stat.Lcharge = 0\n            }\n\n            this.arrayOfProjectiles.push(Projectile)\n        }\n\n        //-------------------------\n        let contx\n\n        window.onload = ()=>{\n            console.log(this.myRef)\n            contx = this.myRef.current.getContext(\"2d\")\n            // console.log( contx)\n\n            this.myRef.current.height = 500//700\n            this.myRef.current.width = 700//900\n\n            //this.MakeMob(\"greenBoi\",200,200)\n        }\n\n        setInterval(()=>{ //<------stuff are done here, since this is what redraws the canvas every so often\n            //console.log(typeof contx) //<-- prints 2 things 1. the actual canvas obj 2. undefine ???\n\n            if(typeof contx !== 'undefined'){ //<--- 'filters out' the above\n                contx.clearRect(0,0,700,500)//-contx.width,contx.height)\n\n                //console.log(contx)\n\n                if(this.otherVar.levelCompleted){ //show arrow move to next level\n                    contx.drawImage(\n                        this.otherVar.arrow,    //image\n                        700-128,\n                        250,\n                        128,\n                        128\n                        )\n                        this.nextLevel()\n\n                }\n\n                contx.drawImage( //draws player\n                    this.mainCharStat.appearance.sprite,    //image\n                    (this.mainCharStat.appearance.frame % this.mainCharStat.appearance.totalFrame)*128,  //sx\n                    0*128,  //sy\n                    128,    //swidth\n                    128,    //sheight\n                    this.mainCharStat.charPosition.x,   //x\n                    this.mainCharStat.charPosition.y,   //y\n                    128,    //width\n                    128     //height\n                    )\n                \n                //makeSwordWave\n                if (this.mainCharStat.stat.Lcharge > 0 && this.otherVar.boardKeyState.downL === false){\n                    //biu biu biu\n                    this.makeProjectile(\"swordWave\",this.mainCharStat.charPosition.x,this.mainCharStat.charPosition.y)\n                    this.mainCharStat.stat.Lcharge = 0\n\n                    //console.log(\"created wave\"+this.mainCharStat.stat.Lcharge)\n                }\n\n                this.appendProjectile(contx)\n                this.appendMob(contx) //move mob moves the mob\n                this.moveMobs() //is in charge mob behavior, doesn't move the mob\n                this.moveChar(contx) //moves charactor\n                    //console.log(this.mainCharStat.appearance.frame % this.mainCharStat.appearance.totalFrame)\n                this.checkForReset(\"mainCharStat\") // check if the animation should reset to default animation\n\n                //this.showHitBox(contx)\n                //console.log(this.state.charHp, this.mainCharStat.stat.maxhp)\n\n                if (this.state.charHp <= 0){\n                    this.mainCharStat.wlkSpd = 0\n                    this.mainCharStat.appearance.sprite=this.sprites.charDied.img\n                    this.mainCharStat.appearance.totalFrame=this.sprites.charDied.totalFrame\n                }\n\n                this.clearDeadMob()\n                this.otherVar.gameTime += 1\n                \n            }\n\n            //contx.drawImage(this.sprites.charWalk, this.charPosition.x, this.charPosition.y,128,128,0,0,128,128)\n\n        },this.otherVar.gameTick);\n\n        window.onkeydown = (e)=>{ // set interval check if key is true or false, then moves character accordingly\n            //console.log(e.key)\n            if (typeof this.otherVar.boardKeyState['down'+e.key.toUpperCase()] !== 'undefined'){//<--prevent making of new down_ variables / null check\n                this.otherVar.boardKeyState['down'+e.key.toUpperCase()] = true\n            }\n            //console.log(this.otherVar.boardKeyState['down'+e.key.toUpperCase()]) \n        }\n\n        window.onkeyup = (e)=>{\n            //console.log(e.key)\n            if (typeof this.otherVar.boardKeyState['down'+e.key.toUpperCase()] !== 'undefined'){//<--prevent making of new down_ variables / null check\n                this.otherVar.boardKeyState['down'+e.key.toUpperCase()] = false\n            }\n            //console.log(this.otherVar.boardKeyState['down'+e.key.toUpperCase()])\n        }\n\n    }\n\n\n    //don't know how this work, it just does i guess.\n    focusCanvas(){\n        this.myRef.current.focus();\n        \n    }\n/*^^^^^^^^^ important canvas will not work without*/\n\n    // setUpCanvasAndDrawPicture(){\n    //     //let contx = this.myRef.canvas.getContext(\"2d\")\n    //     console.log(this.myRef)\n    //     let contx = this.myRef.current.getContext(\"2d\")\n\n    //     // //resize\n    //     // this.myRef.current.height = 700\n    //     // this.myRef.current.width = 900\n\n    //     // console.log(\"aaaaaaaaa\")\n    //     // this.canvasContext.beginPath();\n    //     // this.canvasContext.arc(95, 50, 40, 0, 2 * Math.PI);\n    //     // this.canvasContext.stroke();\n    //     //^^^^^^^^ignore this, but both ^^^ and vvv does the same thing: draw a circle\n    //     // contx.beginPath();\n    //     // contx.arc(95, 50, 40, 0, 2 * Math.PI);\n    //     // contx.stroke();\n\n    //     //setup image to draw\n    //     //let image_CharWalk = new Image()\n    //     //image_CharWalk.src = \"../../../pictures/walkSprite.png\"\n    //     //console.log(contx)\n    //     //console.log(image_CharWalk.width + \" \" + image_CharWalk.height)\n    //     contx.drawImage(this.sprites.charWalk,\n    //                     this.charPosition.x,\n    //                     this.charPosition.y,128,128,0,0,128,128)\n    // }\n    \n\n//----------------------------------------------------------\n\n    render(){            \n\n        return(\n            \n\n       // <div onKeyDown={(e)=>(this.keyHandle(e))}>\n       <div className=\"canholder\">\n\n            <Targetbar target={this.state.mobBeingHit}/>\n            {/* <canvas className=\"can\" ref={(c) => this.canvasContext = c.getContext('2d')}/> */}\n            <canvas className=\"can\" ref={this.myRef} onLoad={()=>console.log(\"loaded\")} />\n            {/* <button onClick={()=>this.setUpCanvasAndDrawPicture()}>aaa</button> */}\n            {/* use below div to test if path is good */}\n            {/* <img src=\"../../../pictures/walkSprite.png\"></img> */}\n            {/* <h1>aaaa{this.state.a}</h1> */}\n            <SelfBar \n                def={this.state.charDef} \n                hp={this.state.charHp} \n                mp={this.state.charMp}\n                mhp={this.mainCharStat.stat.maxhp}\n                mmp={this.mainCharStat.stat.maxmp}\n            />\n\n        </div>\n    )}\n\n    \n    \n}","import React from 'react';\nimport GameCanvas from './components/GameCanvas.js';\nimport Targetbar from './components/TargetBar.js';\nimport './App.css';\n\nfunction App() {\n  let state={\n    phase:\"game\"\n  }\n  \n\n  return (\n    <div className=\"App\">\n      {/* <Targetbar/> */}\n      <GameCanvas name={state.phase} />\n      \n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}